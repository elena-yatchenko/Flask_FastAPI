# ШАБЛОНИЗАТОР JINJA

"""В примере выше мы смогли отрисовать HTML страницу силами Flask. Но если быть
более точным, нам помог шаблонизатор Jinja. При этом сам html файл представляет
статичную страницу сайта. Это удобно для быстрого получения информации
клиентом от сервера. Но крайне неудобно для создания чего-то большего, чем одна
страница. Благодаря Jinja статические html-страницы превращаются в шаблоны для
формирования динамических сайтов"""

# Пробрасываем КОНТЕКСТ из представления в шаблон - {{ }}

"""!!!
Функция render_template после имени шаблона может принимать неограниченное
число именованных аргументов и пробрасывать их в шаблон. Шаблон позволяет
вывести значение по имени, заключив его в двойные фигурные скобки {{ }}. Такие
скобки — аналог функции print() в Python.
"""
from flask import Flask
from flask import render_template

app = Flask(__name__)


# @app.route("/index/")
# def html_index():
#     return render_template("index_jinja.html", name="Харитон")


"""
- Изменим строку вывода в функции, добавив аргумент name со значением «Харитон»
- В шаблоне заменим имя владельца на вывод переменной из шаблона.
"""


"""Jinja не ограничивает пользователя в количестве переменных, которые необходимо
передать в шаблон. Но для сохранения читаемости кода рекомендуется сохранять
все переменные в словарь и пробрасывать в шаблон его распакованный вид.
Распаковка словаря — передача его содержимого как отдельных значений. В
Python для распаковки словаря необходимо добавить две звёздочки ** перед
именем словаря."""

"""Модифицируем нашу функцию представления для передачи не только имени, но и
заголовка страницы.
"""


# @app.route("/index/")
# def index():
#     context = {
#         "title": "Личный блог",
#         "name": "Харитон",
#     }
#     return render_template("index_jinja.html", **context)


"""Теперь в шаблон проброшены переменные name и title и можно заменить
содержимое шаблона внутри тега <title> на переменную.

<title>{{ title }}</title>
"""
"""� Внимание! До и после двойных фигурных скобок рекомендуется оставлять
пробел. Это не только облегчает чтение, но и в некоторых случаях заставляет код работать верно.
"""


# УСЛОВНЫЙ ОПЕРАТОР В ШАБЛОНЕ - {% %}

"""
Ветвления в Jinja имеют схожую с Python логику, но немного отличаются по
синтаксису. Оператор if и логическое условие заключаются в скобки вида {% %}. В
отличие от Python обязательным является закрывающий условие код вида {% endif %}."""

# {% if user %}
# <p>Вы вошли под именем {{ user }}</p>
# {% endif %}

"""Если в шаблон передали переменную user, будет выведен абзац текста. В
противном случае код между открывающим и закрывающим операторами будет
проигнорирован, не появится на стороне клиента.
"""
"""
Как и в Python, шаблоны поддерживают сложные условия благодаря конструкциям {% elif %} и {% else %}
Например мы можем выбирать окончание предложения в зависимости от переданного числа
"""

# <p>К прочтению предлагается {{ number }}
# {% if number == 1 %}
# пост
# {% elif 2 <= number <= 4 %}
# поста
# {% else %}
# постов
# {% endif %}
# </p>

"""� Важно! Не забудьте добавить ключ number в словарь context для
пробрасывания переменной из функции в шаблон.
"""


# @app.route("/index/")
# def index():
#     context = {"title": "Личный блог", "name": "Харитон", "number": 2}
#     return render_template("index_jinja.html", **context)


# if __name__ == "__main__":
#     app.run()

# ВЫВОД В ЦИКЛЕ

"""Аналогично Python, можно использовать цикл for внутри шаблона для вывода
элементов последовательности. Из примера ниже понятно, что цикл заключается в
специальные скобки {% %}, а конец цикла обязательно заканчивается блоком {% endfor %}
"""
# {% for item in item_list %}
# {{ item }}
# {% endfor %}

"""Изменим представление poems(), которое создали ранее на лекции. Сформируем
аналогичный вывод стихотворения силами шаблонизатора Jinja.
Помещаем список со строками стихотворения в словарь и пробросим его в шаблон."""


# @app.route("/poems/")
# def poems():
#     context = {
#         "poem": [
#             "Вот не думал, не гадал,",
#             "Программистом взял и стал.",
#             "Хитрый знает он язык,",
#             "Он к другому не привык.",
#         ]
#     }
#     return render_template("poems.html", **context)


# if __name__ == "__main__":
#     app.run()

"""Как и в Python, условия и циклы можно использовать совместно, помещая одно в
другое в зависимости от задач программиста."""

# ВЫВОД СЛОЖНЫХ СТРУКТУР В ЦИКЛЕ

"""Иногда необходимо вывести информацию о нескольких однотипных объектах с
набором свойств. Например, информацию о пользователях из базы данных. Или
если упростить задачу, список словарей с одинаковыми ключами. Для опытных
программистов очевидно, что оба вывода идентичны. Рассмотрим список словарей.
"""


@app.route("/users/")
def users():
    _users = [
        {
            "name": "Никанор",
            "mail": "nik@mail.ru",
            "phone": "+7-987-654-32-10",
        },
        {
            "name": "Феофан",
            "mail": "feo@mail.ru",
            "phone": "+7-987-444-33-22",
        },
        {
            "name": "Оверран",
            "mail": "forest@mail.ru",
            "phone": "+7-903-333-33-33",
        },
    ]
    context = {"users": _users}
    return render_template("users.html", **context)


"""При выводе в шаблоне используем точечную нотацию для доступа к элементам списка словарей (не по ключу, как в python)
НО!!! Это работает, только если ключи из одного слова и на латинском. Иначе - работать как со списком: обращение по ключу
и выведение данных через цикл (см. задачу 6 семинара 1, user.html)
"""

if __name__ == "__main__":
    app.run()
