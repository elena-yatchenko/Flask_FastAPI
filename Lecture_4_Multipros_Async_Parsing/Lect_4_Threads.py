# Введение в многозадачность в Python

"""
В современном программировании часто возникает необходимость выполнять
несколько задач одновременно. Для этого используется многозадачность —
способность компьютера или программы обрабатывать несколько задач
одновременно.
В Python существует несколько подходов к реализации многозадачности, каждый
из которых имеет свои преимущества и недостатки. Прежде чем начать
использовать многозадачность в своих программах, необходимо понимать
основные понятия и подходы.

Поток выполнения — это независимая последовательность инструкций, которая
может выполняться параллельно с другими потоками. Каждый поток имеет свой
стек вызовов и свой контекст выполнения.

Процесс — это экземпляр программы, который запущен на компьютере. Каждый
процесс имеет свой собственный адресное пространство, в котором хранятся
данные и код программы. Процессы могут выполняться параллельно на разных
ядрах процессора.

Далее рассмотрим различные подходы к многозадачности в Python и их
применение в различных ситуациях.
"""
# Синхронный подход

"""
Синхронный код — это код, который выполняется последовательно, одна операция
за другой. Когда программа выполняет какую-то операцию, она блокируется до тех
пор, пока операция не будет завершена. Таким образом, если в программе есть
долгие операции, они могут занимать много времени и приводить к задержкам в
работе программы.

Примеры синхронных операций в Python:
● чтение данных из файла
● отправка запроса на сервер и получение ответа
● выполнение сложных математических операций
● ожидание пользовательского ввода

Ограничения синхронного кода:
● задержки в работе программы из-за долгих операций
● невозможность выполнения нескольких задач одновременно
● ограниченность производительности

Для решения этих проблем можно использовать многопоточный или
многопроцессорный подход. Однако, при использовании многопоточности и
многопроцессорности возникают свои проблемы, такие как конкуренция за
ресурсы и возможные блокировки.

Примеры программа на Python

Пример 1:
"""
import time


def count_down(n):
    for i in range(n, 0, -1):
        print(i)
        time.sleep(1)


count_down(5)

"""
Эта программа выводит обратный отсчет от заданного числа до 1 с интервалом в 1
секунду. В данном случае это синхронный код, так как каждое выполнение цикла
for блокирует выполнение программы на 1 секунду.

Пример 2:
"""
import time


def slow_function():
    print("Начало функции")
    time.sleep(5)
    print("Конец функции")


print("Начало программы")
slow_function()
print("Конец программы")

"""
Эта программа вызывает функцию slow_function(), которая занимает 5 секунд на
выполнение. Весь код работает синхронно, то есть выполнение программы
блокируется на время выполнения функции.

Пример 3:
"""
import random
import time


def long_running_task():
    for i in range(5):
        print(f"Выполнение задачи {i}")
        time.sleep(random.randint(1, 3))


def main():
    print("Начало программы")
    long_running_task()
    print("Конец программы")


main()

"""
Эта программа запускает длительную задачу long_running_task(), которая
выполняется в течение случайного времени от 1 до 3 секунд. Весь код работает
синхронно, поэтому выполнение программы блокируется на время выполнения
задачи.

В целом, синхронный код может быть полезен для простых задач, но он может стать
проблемой при работе с длительными операциями или задачами, требующими
большого количества вычислений. В таких случаях лучше использовать
многопоточный или асинхронный код.
"""

# Многопоточный подход

"""
Многопоточный код — это подход к многозадачности, при котором программа
может выполнять несколько задач одновременно в разных потоках выполнения.
Каждый поток выполняет свою задачу независимо от других потоков, что позволяет
улучшить производительность программы.

Примеры многопоточных операций в Python:
● загрузка данных из нескольких файлов одновременно
● параллельная обработка большого объема данных
● одновременное выполнение нескольких запросов к базе данных
● многопоточный веб-сервер, обрабатывающий несколько запросов
одновременно

Преимущества многопоточного кода:
● увеличение производительности программы за счет параллельного
выполнения задач
● возможность выполнения нескольких задач одновременно без блокировки

Недостатки многопоточного кода:
● возможность возникновения конкуренции за ресурсы
● сложность отладки и тестирования многопоточных программ
● возможность блокировки потоков выполнения

Для решения проблем, связанных с конкуренцией за ресурсы и блокировками
потоков, можно использовать механизмы синхронизации, такие как блокировки и
семафоры. Однако, неправильное использование этих механизмов может привести
к дедлокам (deadlock) и другим проблемам.

При разработке многопоточных программ необходимо учитывать особенности
языка Python, такие как GIL (Global Interpreter Lock), который ограничивает
параллелизм в исполнении Python-кода. Это означает, что в Python нельзя
использовать несколько ядер процессора для выполнения одной программы.

В целом, многопоточный подход позволяет улучшить производительность
программы и выполнить несколько задач одновременно без блокировки. Однако,
при разработке многопоточных программ необходимо учитывать особенности
языка Python и правильно использовать механизмы синхронизации для избежания
проблем.

Примеры программа на Python

Пример 1:
"""

import threading
import time


def worker(num):
    print(f"Начало работы потока {num}")
    time.sleep(3)
    print(f"Конец работы потока {num}")


threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print("Все потоки завершили работу")

"""
Эта программа создает 5 потоков и запускает функцию worker() в каждом из них.
Функция worker() занимает 3 секунды на выполнение. Весь код работает
многопоточно, то есть каждый поток работает независимо от других, и выполнение
программы не блокируется на время выполнения функции.

Пример 2:
"""
import threading
import time


def worker(num):
    print(f"Начало работы потока {num}")
    time.sleep(3)
    print(f"Конец работы потока {num}")


threads = []

for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
for t in threads:
    t.start()
    t.join()

print("Все потоки завершили работу")

"""
Эта программа создает 5 потоков и запускает функцию worker() в каждом из них.
Функция worker() занимает 3 секунды на выполнение. Весь код работает
многопоточно, но в отличие от предыдущего примера, потоки запускаются и
завершаются последовательно, блокируя выполнение программы на время
выполнения каждого потока.

Пример 3:
"""

import threading

counter = 0


def increment():
    global counter
    for _ in range(1_000_000):
        counter += 1
    print(f"Значение счетчика: {counter:_}")


threads = []
for i in range(5):
    t = threading.Thread(target=increment)
    threads.append(t)
    t.start()
for t in threads:
    t.join()

print(f"Значение счетчика в финале: {counter:_}")

"""
Эта программа создает 5 потоков и запускает функцию increment() в каждом из них.
Функция increment() увеличивает значение глобальной переменной counter на 1
миллион раз. Весь код работает многопоточно, но из-за того, что несколько потоков
работают с одной переменной, может возникнуть проблема гонки данных (race
condition), когда результат выполнения программы может быть непредсказуемым.

Многопоточный код позволяет выполнять несколько задач параллельно, что может
значительно ускорить выполнение программы. Однако при работе с общими
ресурсами (например, глобальными переменными) может возникнуть проблема
гонки данных, которую необходимо учитывать при написании многопоточного кода.
"""

# чуть отличный от лекции вариант оформления

"""
Чтобы гарантировать завершение всех потоков в Python, вам необходимо создать нужное количество экземпляров 
класса threading.Thread и вызвать метод .join(). 
Для удобства управления потоками, их можно организовать в список.

Метод .start() запускает поток, а .join() приводит ко взаимодействию с главным потоком 
до окончания выполнения каждого созданного потока.
Примерное представление этого процесса в коде:
"""
import threading


def task():
    print("Поток запущен")


threads = [threading.Thread(target=task) for _ in range(5)]
for thread in threads:
    thread.start()
for thread in threads:
    thread.join()

print("Все потоки завершили свою работу.")
