# FLASH СООБЩЕНИЯ

"""Flash сообщения в Flask являются способом передачи информации между
запросами. Это может быть полезно, например, для вывода сообщений об
успешном выполнении операции или об ошибках ввода данных.
Для работы с flash сообщениями используется функция flash(). Она принимает
сообщение и категорию, к которой это сообщение относится, и сохраняет его во
временном хранилище."""

"""Например, чтобы вывести сообщение об успешной отправке формы, можно
использовать следующий код:"""

from flask import Flask, flash, redirect, render_template, request, url_for

app = Flask(__name__)
app.secret_key = b"5f214cacbd30c2ae4784b520f17912ae0d5d8c16ae98128e3f549546221265e4"


# @app.route("/form", methods=["GET", "POST"])
# def form():
#     if request.method == "POST":
#         # Обработка данных формы
#         flash("Форма успешно отправлена!", "success")
#         return redirect(url_for("form"))
#     return render_template("form.html")


"""В этом примере мы определяем маршрут '/form' для отображения и обработки
формы. Если метод запроса POST, то происходит обработка данных формы и
выводится сообщение об успешной отправке с помощью функции flash() и
категории 'success'. Затем происходит перенаправление на страницу с формой с
помощью функции redirect().
"""


# СЕКРЕТНЫЙ КЛЮЧ

"""Небольшое отступление. Чтобы не получать ошибки вида при работе с сессией

RuntimeError: The session is unavailable because no secret key was set. 
Set the secret_key on the application to something unique and secret.

необходимо добавить в Flask приложение секретный ключ.
Простейший способ генерации такого ключа, выполнить следующие пару строк
кода

>>> import secrets
>>> secrets.token_hex()

!!! Сразу после создания приложения прописываем инициализацию ключа
сгенерированным набором байт. Теперь данные в безопасности, можно продолжать
развивать приложение.
"""

# ШАБЛОН ДЛЯ FLASH-СООБЩЕНИЙ

"""Чтобы вывести flash сообщения в HTML шаблоне, можно использовать следующий
код шаблона: см. form.html"""

""" Код в шаблоне использует функцию get_flashed_messages() для получения всех flash
сообщений с категориями (блок with). Далее проверяем передавались ли
сообщения через flash. Если да, в цикле происходит получение категорий и
сообщений, т.к. указан параметр with_categories=true. Далее их вывод в
соответствующих блоках с применением стилей bootstrap.

Т.е. функция get_flashed_messages() возвращает 
все сообщения, переданные через flash и пока не отображенные"""

"""
!!!!! Сначала пользователю просто выводится форма (БЕЗ флеш-сообщений), когда он ее заполняет, происходит
перенаправление пользователя опять на форму /form, НО уже с учетом работы блока WITH, т.к. 
теперь у нас есть успешно отправленная форма и есть одно сообщение об успехе. Его пользователь
и увидит на обновленной форме """

# КАТЕГОРИИ FLASH-СООБЩЕНИЙ

"""Категории сообщений в flash позволяют различать типы сообщений и выводить их
по-разному. Категория по умолчанию message. Но вторым аргументом можно
передавать и другие категории, например warning, success и другие.
Например, чтобы вывести сообщение об ошибке ввода данных, можно
использовать следующую модификацию функции:"""

"""скорректируем фукнцию form для выведения предупреждающего сообщения категории warning"""
"""Проверяем данные формы на наличие имени. Если имя не указано, то выводится
сообщение об ошибке с категорией danger и происходит перенаправление на
страницу с формой. Сама форма будет работать без изменений."""


@app.route("/form", methods=["GET", "POST"])
def form():
    if request.method == "POST":
        # Проверка данных формы
        if not request.form["name"]:
            flash("Введите имя!", "danger")
            return redirect(url_for("form"))
        # Обработка данных формы
        flash("Форма успешно отправлена!", "success")
        return redirect(url_for("form"))
    return render_template("form.html")


if __name__ == "__main__":
    app.run(debug=True)
    # app.run()

"""Flash сообщения являются удобным способом передачи информации между
запросами в Flask. Они позволяют выводить сообщения пользователю и упрощают
обработку ошибок и успешных операций"""

"""!!!
Когда вы вызываете функцию flash(), Flask сохраняет сообщение, но на веб-страницах не будут появляться магические сообщения. Шаблоны приложения должны отображать эти свернутые сообщения таким образом, который работает для макета сайта. Я собираюсь добавить эти сообщения в базовый шаблон, чтобы все шаблоны наследовали эту функциональность. Это обновленный базовый шаблон:

<html>
    <head>
        {% if title %}
        <title>{{ title }} - microblog</title>
        {% else %}
        <title>microblog</title>
        {% endif %}
    </head>
    <body>
        <div>
            Microblog:
            <a href="/index">Home</a>
            <a href="/login">Login</a>
        </div>
        <hr>
        {% with messages = get_flashed_messages() %}
        {% if messages %}
        <ul>
            {% for message in messages %}
            <li>{{ message }}</li>
            {% endfor %}
        </ul>
        {% endif %}
        {% endwith %}
        {% block content %}{% endblock %}
    </body>
</html>

Здесь я использую конструкцию with, чтобы назначить результат вызова get_flashed_messages() переменной messages, 
все в контексте шаблона. Функция get_flashed_messages() поступает из Flask и возвращает список всех сообщений, 
которые были зарегистрированы в flash() ранее. Условие, которое следует, проверяет, 
имеет ли сообщение некоторый контент, и в этом случае элемент <ul>отображается с каждым сообщением 
в виде элемента списка <li>. 
Этот стиль рендеринга выглядит не очень хорошо, но тема стилизации веб-приложения появится позже.

Интересным свойством этих flash-сообщений является то, что после их запроса один раз через функцию 
get_flashed_messages они удаляются из списка сообщений, поэтому они появляются только 
один раз после вызова функции flash().

from flask import render_template, flash, redirect

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        flash('Login requested for user {}, remember_me={}'.format(
            form.username.data, form.remember_me.data))
        return redirect('/index')
    return render_template('login.html', title='Sign In', form=form)
"""